\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}

% Define the page margin
\usepackage[margin=3cm]{geometry}

% Better typography (font rendering)
\usepackage{microtype}

% Math environments and macros
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

% Define \includegraphics to include graphics
\usepackage{graphicx}

% Draw graphics from a text description
\usepackage{tikz}

% Syntax highlighting
\usepackage{minted}

% Set global minted options
\setminted{linenos, autogobble, frame=lines, framesep=2mm}

% Import the comment environment for orgtbl-mode
\usepackage{comment}

% Do not indent paragraphs
\usepackage{parskip}

\title{Predicting Lost Packets}
\author{Marten Lienen, Julius Michaelis}

\begin{document}

\maketitle

\section{The Problem}

In network coding you group packets in generations of $n$ packets and send random linear combinations of them to your communication partners.
We know that the network is lossy -- the wireless network in particular -- and with this technique network coding already accounts for it because it does not matter which packets the destination receives as long as it receives $n$ packets at all, save for occasionally occuring combinations that are linearly dependent on previous packets.
So the sender has to keep sending random linear combinations until it receives $n$ ACKs.
This effort could be diminished if you knew in before how many packets would get lost and could inject a proportionate amount of redundancy into the network right from the beginning.

Our contributions to this problem are
\begin{itemize}
\item a model for estimation of the packet success probility distribution instead of only its mean
\item a formula to derive a number $n'$ of redundant packets to inject so that the destination receives $n$ packets with a certain probability
\end{itemize}

\section{Model}

A dataflow is a sequence of packets $p_{1}, p_{2}, \dots$ sent at times $t_{1}, t_{2}, \dots$ from a source $S$ to a destination $D$.
However the data transport medium is unreliable so that packets can go missing.
We track this with a sequence of random variables $P_{1}, P_{2}, \dots$ that are defined to be $1$ if $p_{i}$ was successfully delivered and $0$ otherwise.
This means that each of these sending procedures $P_{i}$ is a Poisson trial with success probability $s_{i}$.
The $s_{i}$ are then again random variables on the real interval $[0, 1]$.
We call them packet success probabilities because they describe the probability that a packet transfer is successful at time $t_{i}$.

A reasonable choice to model the probability distribution of the $s_{i}$ would be a Beta distribution with parameters $\alpha_{i} \ge 1$ and $\beta_{i} \ge 1$.
This distribution can model a uniform distribution on $[0, 1]$ as well as a smooth, unimodal distribution.

\section{Updating the model}

Whenever you register a packet loss, you add $1$ to the $\beta$ parameter of the current prior.
When a packet is received, you add $1$ to the $\alpha$ parameter of the current prior instead.

\section{Trust Function Model}

Say the last point of measurement was $t_{i}$ and we want to predict the distribution of the success probability $s'$ at time $t_{i} + t'$.
In the trust function model we still believe in the latest measurement, but we might believe less so depending on the time $t'$ that has passed.
This degree of trust is captured in a trust function $T(t) : \mathbb{R}_{\ge 0} \rightarrow [0, 1]$, where a value of $1$ means that you believe the old data completely while a value of $0$ means that you do not trust it at all.
Some reasonable things to expect from a trust function are
\begin{itemize}
\item $T(0) = 1$ because you should believe in your measurements
\end{itemize}

\subsection{$T = 0$}

\subsection{$T = 1$}

\subsection{$T(t) = \exp(-t)$}

\section{Predicting Redundancy}

\begin{equation*}
  P \sim Beta(\alpha, \beta)
\end{equation*}
\begin{equation*}
  X \sim NB(n, P)
\end{equation*}
\begin{align*}
  P[X > k] & = \int_{0}^{1} P[X > k \mid P = p] \cdot P[P = p]\ dp\\
           & = \int_{0}^{1} I_{p}(k + 1, n) \cdot \frac{1}{B(\alpha, \beta)} p^{\alpha - 1}(1 - p)^{\beta - 1}\ dp\\
           & = \int_{0}^{1} \frac{B(p; k + 1, n)}{B(k + 1, n)} \cdot \frac{1}{B(\alpha, \beta)} p^{\alpha - 1}(1 - p)^{\beta - 1}\ dp\\
\end{align*}

\section{Linux}

At least some of linux's wireless drivers use exponential moving average.

\begin{minted}{c}
  static void atmel_smooth_qual(struct atmel_private *priv)
  {
    unsigned long time_diff = (jiffies - priv->last_qual) / HZ;
    while (time_diff--) {
      priv->last_qual += HZ;
      priv->wstats.qual.qual = priv->wstats.qual.qual / 2;
      priv->wstats.qual.qual +=
        priv->beacons_this_sec * priv->beacon_period * (priv->wstats.qual.level + 100) / 4000;
      priv->beacons_this_sec = 0;
    }
    priv->wstats.qual.updated |= IW_QUAL_QUAL_UPDATED;
    priv->wstats.qual.updated &= ~IW_QUAL_QUAL_INVALID;
  }
\end{minted}

\end{document}
